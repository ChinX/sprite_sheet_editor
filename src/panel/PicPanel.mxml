<?xml version="1.0" encoding="utf-8"?>
<s:HGroup xmlns:fx="http://ns.adobe.com/mxml/2009" 
		  xmlns:s="library://ns.adobe.com/flex/spark" 
		  xmlns:comps="comps.*"
		  horizontalAlign="center"
		  implements="interf.IStateChanged">
	<s:BorderContainer width="300" height="100%"  borderColor="0x878787" backgroundAlpha="0">
		<s:layout>
			<s:VerticalLayout horizontalAlign="center" paddingBottom="5" paddingLeft="5" paddingRight="5" paddingTop="5"/>
		</s:layout>
		<s:BorderContainer width="100%" backgroundColor="0x696969" height="80">
			<s:layout>
				<s:VerticalLayout horizontalAlign="center" paddingBottom="5" paddingLeft="5" paddingRight="5" paddingTop="5"/>
			</s:layout>
			<s:Label text="帧设置(x,y,w,h)" fontWeight="bold"/>
			<s:CheckBox id="useOriginalSizeCB" label="使用帧的原始大小"/>
			<s:HGroup width="100%" enabled="{!useOriginalSizeCB.selected}">
				<s:NumericStepper id="frameX" width="100%" value="@{pic.transf.x}" minimum="0" maximum="{pic.viewer.width-1}"/>
				<s:NumericStepper id="frameY" width="100%" value="@{pic.transf.y}" minimum="0" maximum="{pic.viewer.height-1}"/>
				<s:NumericStepper id="frameW" width="100%" value="@{pic.transf.width}" minimum="1" maximum="{pic.viewer.width}"/>
				<s:NumericStepper id="frameH" width="100%" value="@{pic.transf.height}" minimum="1" maximum="{pic.viewer.height}"/>
			</s:HGroup>
		</s:BorderContainer>
		<comps:FileManager id="fileM" width="100%" height="100%" selectionChange="handler_selectionChange(event)" selectionChanging="handler_selectionChanging(event)"/>
		<comps:BuildSetting id="buildSetting" width="100%" backgroundColor="0x696969" enabled="{fileM.fileList.length>0}" build="handler_buildClick(event)"/>
	</s:BorderContainer>
	<comps:ImagePreview id="pic" width="100%" height="100%" borderColor="0x878787" backgroundAlpha="0"  showTransformTool="{!useOriginalSizeCB.selected}"/>
	<fx:Script>
	<![CDATA[
		import events.InfoEvent;
		
		import org.zengrong.display.spritesheet.SpriteSheetMetadata;
		
		import type.StateType;
		
		import utils.FileProcessor;
		import utils.Funs;
		import utils.Global;
		
		private var _frameNum:int;					//当前正在处理的帧编号
		
		//----------------------------------------
		// getter/setter
		//----------------------------------------
		
		public function get frameWidth():int
		{
			return useOriginalSizeCB.selected ? pic.actualWidth : frameW.value;
		}
		
		public function get frameHeight():int
		{
			return useOriginalSizeCB.selected ? pic.actualHeight : frameH.value;
		}
		
		public function getFrameRect():Rectangle
		{
			if(useOriginalSizeCB.selected)
				return new Rectangle(0,0,pic.actualWidth, pic.actualHeight);
			return new Rectangle(frameX.value,frameY.value,frameW.value,frameH.value);
		}
		//----------------------------------------
		// public
		//----------------------------------------
		
		public function updateOnStateChanged($old:String, $new:String):void
		{
			trace('picPanel updateOnStateChanged:', $new);
			if($new == StateType.PIC)
			{
				//如果是从START状态跳转过来的，就更新一次fileList的值
				if($old == StateType.START)
					fileM.setFileList(FileProcessor.instance.selectedFiles);
				pic.transf.init();
			}
			else
			{
				pic.viewer.source = null;
				pic.transf.destroy();
			}
		}
		
		//----------------------------------
		//  绘制相关方法
		//----------------------------------
		
		private function capture():void
		{
			trace('pic capture');
			var __dimension:Object = getSheetDimension(
				buildSetting.whDDL.selectedIndex == 0, 
				buildSetting.dimensionNS.value,
				fileM.fileList.length);
			
			trace(__dimension.w, __dimension.h, __dimension.rects);
			var __meta:SpriteSheetMetadata = null;
			//如果能够生成meta直接将计算好的Vector保存到metadata中
			if(__dimension.rects)
			{
				__meta = new SpriteSheetMetadata((__dimension.rects  as Vector.<Rectangle>).length);
				__meta.frameSizeRect = __dimension.rects;
			}
			var __bmd:BitmapData = new BitmapData(__dimension.w, __dimension.h, buildSetting.transparentCB.selected, buildSetting.bgColorPicker.selectedColor)
			//根据计算出的Sheet宽高重置bmd
			Funs.resetSheet(__bmd, __meta);
			_frameNum = 0;
		}
		
		/**
		 * 通过当前帧应该放置的位置
		 * @param $limitW 是否限制宽度，若为否则是限制高度
		 * @param $wh 被限制的宽度或者高度的最大值
		 * @param $frameNum 总帧数
		 * @return 返回一个Object，其中的w代表sheet宽度，h代表sheet高度，rects代表sheet中每帧的位置和大小的Vector.<Rectangle>
		 */
		private function getSheetDimension($limitW:Boolean, $wh:int, $frameNum:int):Object
		{
			//sheet的宽高
			var __sw:int = 0;
			var __sh:int = 0;
			//frame的宽高
			var __fw:int = frameWidth;
			var __fh:int = frameHeight;
			//设置sheet的初始宽高
			if($limitW)
			{
				__sw = $wh;
				__sh = __fh;
			}
			else
			{
				__sh = $wh;
				__sw = __fw;
			}
			//如果使用原始大小，rects需要在载入的过程中填充，这里就只能返回w和h
			if(useOriginalSizeCB.selected)
				return {w:__sw, h:__sh};
			
			var __rect:Rectangle = new Rectangle(0,0,__fw,__fh);
			//直接加入第一个尺寸，第一个不参与计算
			var __rects:Vector.<Rectangle> = Vector.<Rectangle>([__rect.clone()]);
			//由于第一个尺寸已经加入，循环从第二个元素开始(i=1)
			for (var i:int = 1; i < $frameNum; i++) 
			{
				//限制宽度的计算
				if($limitW)
				{
					//如果这一行的宽度已经不够放下当前的位图，就将其放在下一行的开头
					if(__rect.right + __fw > __sw)
					{
						__rect.x = 0;
						__rect.y += __fh;
					}
					else
					{
						__rect.x += __rect.width;
					}
					__sh = __rect.bottom;
				}
					//限制高度的计算
				else
				{
					//如果这一列的高度已经放不下当前的位图，就将其放在下一列的开头
					if(__rect.bottom + __fh > __sh)
					{
						__rect.y = 0;
						__rect.x += __fw;
					}
					else
					{
						__rect.y += __rect.height;
					}
					__sw = __rect.right;
				}
				//将计算出的位置加入Vector
				__rects[i] = __rect.clone();
			}
			return {w:__sw,h:__sh,rects:__rects};
		}
		
		/**
		 * 绘制一帧，并开始载入下一帧的图片
		 */
		private function drawFrame():void
		{
			if (_frameNum < fileM.fileList.length)
			{
				trace('drawing frame:', _frameNum)
				pic.viewer.source = (fileM.fileList.getItemAt(_frameNum)).url;
				_frameNum ++;
			}
			else
			{
				pic.viewer.removeEventListener(Event.COMPLETE, handler_picLoadDone);
			}
		}
		
		/**
		 * 绘制当前帧，返回位图
		 */
		private function drawBMD():BitmapData
		{
			var __bmd:BitmapData = new BitmapData(frameWidth, frameHeight, buildSetting.transparentCB.selected, buildSetting.bgColorPicker.selectedColor);
			if(useOriginalSizeCB.selected)
			{
				__bmd.draw(pic.viewer.content, null, null, null, null, buildSetting.smoothCB.selected);
			}
			else
			{
				//需要向“左上角”移动，将当前帧绘制成位图
				var __ma:Matrix = new Matrix();
				__ma.translate(-1*frameX.value, -1*frameY.value);
				__bmd.draw(pic.viewer.content, __ma, null, null, null, buildSetting.smoothCB.selected);
			}
			return __bmd;
		}
		
		//----------------------------------------
		// handler
		//----------------------------------------
		
		protected function handler_buildClick($event:InfoEvent):void
		{
			pic.viewer.source = null;
			pic.viewer.addEventListener(Event.COMPLETE, handler_picLoadDone);
			capture();
		}
		
		private function handler_picLoadDone($evt:Event):void
		{
			var __bmd:BitmapData =  drawBMD();
			//向Sheet中添加这个位图
			Global.instance.sheet.addFrame(__bmd);
		}
		
		protected function handler_selectionChanging($event:InfoEvent):void
		{
			var __item:Object = fileM.fileDG.selectedItem;
			if(__item)
			{
				//在选择的项目被修改之前，将这个项目的Rect进行保存
				__item.rect = getFrameRect();
				trace(__item.rect);
			}
		}
		
		protected function handler_selectionChange($event:InfoEvent):void
		{
			var __item:Object = fileM.fileDG.selectedItem;
			if(__item)
			{
				pic.viewer.source = __item.file.url;
				//若为这个文件记录了rect，则改变当前rect的显示
				if(__item.rect)
					pic.transf.transformFromRect(__item.rect);
			}
			else
			{
				pic.viewer.source = null;
			}
		}
		
	]]>
	</fx:Script>
</s:HGroup>
