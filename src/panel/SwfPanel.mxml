<?xml version="1.0" encoding="utf-8"?>
<s:HGroup xmlns:fx="http://ns.adobe.com/mxml/2009" 
		  xmlns:s="library://ns.adobe.com/flex/spark"
		  xmlns:comps="comps.*"
		  implements="interf.IStateChanged"
		  xmlns:mx="library://ns.adobe.com/flex/mx">
	<s:BorderContainer width="300" height="100%" borderColor="0x878787" backgroundAlpha="0">
		<s:layout>
			<s:VerticalLayout horizontalAlign="center" paddingBottom="5" paddingLeft="5" paddingRight="5" paddingTop="5"/>
		</s:layout>
		<s:VGroup width="100%">
			<s:CheckBox id="useOriginalSizeCB" label="使用帧的原始大小"/>
			<s:Label text="帧设置(x,y,w,h):"/>
			<s:HGroup width="100%" enabled="{!useOriginalSizeCB.selected}">
				<s:NumericStepper id="frameX" width="100%" value="@{swf.transf.x}" minimum="0" maximum="{swf.viewer.width-1}"/>
				<s:NumericStepper id="frameY" width="100%" value="@{swf.transf.y}" minimum="0" maximum="{swf.viewer.height-1}"/>
				<s:NumericStepper id="frameW" width="100%" value="@{swf.transf.width}" minimum="1" maximum="{swf.viewer.width}"/>
				<s:NumericStepper id="frameH" width="100%" value="@{swf.transf.height}" minimum="1" maximum="{swf.viewer.height}"/>
			</s:HGroup>
		</s:VGroup>
		<s:HGroup width="100%" verticalAlign="middle">
			<s:Label text="第一帧(0基)："/>
			<s:NumericStepper id="firstFrameNS" maximum="1000" minimum="0" stepSize="1" width="100%"/>
			<s:Label text="总帧数："/>
			<s:NumericStepper id="totalFrameNS" maximum="10000" minimum="1" stepSize="1" width="100%"/>
		</s:HGroup>
		<comps:BmpSetting id="bmpSetting" width="100%"/>
		<s:Button id="buildBTN" label="生成" height="40" width="80" enabled="{_state&amp;&amp;_state==StateType.LOAD_DONE}" click="handler_buildClick(event)"/>
	</s:BorderContainer>
	<comps:ImagePreview id="swf" width="100%" height="100%" borderColor="0x878787" backgroundAlpha="0"/>
	<fx:Script>
	<![CDATA[
		import flash.utils.setTimeout;
		
		import mx.binding.utils.ChangeWatcher;
		import mx.events.FlexEvent;
		import mx.events.PropertyChangeEvent;
		
		import org.zengrong.display.spritesheet.SpriteSheetMetadata;
		
		import type.StateType;
		
		import utils.Funs;
		import utils.Global;
		
		private var _frameNum:int;					//当前正在播放的帧的索引
		[Bindable] private var _state:String;		//当前的处理状态
		
		//----------------------------------------
		// getter/setter
		//----------------------------------------
		/**
		 * 获取选择的swf文件的路径
		 */
		public function get swfUrl():String
		{
			return File(Global.instance.files.getItemAt(0)).url;
		}
		
		public function get frameWidth():int
		{
			return useOriginalSizeCB.selected ? swf.actualWidth : frameW.value;
		}
		
		public function get frameHeight():int
		{
			return useOriginalSizeCB.selected ? swf.actualHeight : frameH.value;
		}
		//----------------------------------------
		// public
		//----------------------------------------
		
		public function updateOnStateChanged($old:String, $new:String):void
		{
			trace('swfPanel updateOnStateChanged:', $new);
			if($new == StateType.SWF)
			{
				swf.viewer.addEventListener(Event.COMPLETE, handler_swfLoadDone);
				swf.viewer.load(swfUrl);
				swf.transf.init();
			}
			else
			{
				swf.viewer.removeEventListener(Event.COMPLETE, handler_swfLoadDone);
				swf.transf.destroy();
			}
		}
		
		//----------------------------------
		//  绘制相关方法
		//----------------------------------
		
		private function capture():void
		{
			trace('capture');
			_state = StateType.PROCESSING;
			var __dimension:Object = getSheetDimension();
			trace(__dimension.w, __dimension.h, __dimension.rects);
			//直接将计算好的Vector保存到metadata中
			var __meta:SpriteSheetMetadata = new SpriteSheetMetadata((__dimension.rects  as Vector.<Rectangle>).length);
			__meta.frameSizeRect = __dimension.rects;
			var __bmd:BitmapData = new BitmapData(__dimension.w, __dimension.h, bmpSetting.transparentCB.selected, bmpSetting.bgColorPicker.selectedColor)
			//根据计算出的Sheet宽高重置bmd
			Funs.resetSheet(__bmd, __meta);
			//帧索引永远从0开始，无论正在播放的主时间轴有几帧（可能只有1帧，使用MC做动画），也可以实现多帧捕获
			_frameNum = 0;
			this.addEventListener(Event.EXIT_FRAME, drawFrame);
			drawFrame();
		}
		
		private function captureDone():void
		{
			_state = StateType.LOAD_DONE;
			Funs.changeState(StateType.SS);
		}
		
		/**
		 * 绘制一帧，并判断所有帧绘制是否完成
		 */
		private function drawFrame(evt:Event=null):void
		{
			if (_frameNum++ >= firstFrameNS.value)
			{
				trace('drawing frame:', _frameNum-1)
				var __bmd:BitmapData =  drawBMD();
				//向Sheet中添加这个位图
				Global.instance.sheet.addFrame(__bmd);
			}
			//所有帧捕获完毕后取消侦听
			if (_frameNum - firstFrameNS.value >= totalFrameNS.value)
			{
				this.removeEventListener(Event.EXIT_FRAME, drawFrame);
				captureDone();
			}
		}
		
		/**
		 * 绘制当前帧，返回位图
		 */
		private function drawBMD():BitmapData
		{
			var __bmd:BitmapData = new BitmapData(frameWidth, frameHeight, bmpSetting.transparentCB.selected, bmpSetting.bgColorPicker.selectedColor);
			if(useOriginalSizeCB.selected)
			{
				__bmd.draw(swf.viewer.content, null, null, null, null, bmpSetting.smoothCB.selected);
			}
			else
			{
				//需要向“左上角”移动，将当前帧绘制成位图
				var __ma:Matrix = new Matrix();
				__ma.translate(-1*frameX.value, -1*frameY.value);
				__bmd.draw(swf.viewer.content, __ma, null, null, null, bmpSetting.smoothCB.selected);
			}
			return __bmd;
		}
		
		/**
		 * 通过当前帧应该放置的位置
		 * @return 返回一个Object，其中的w代表sheet宽度，h代表sheet高度，rects代表sheet中每帧的位置和大小的Vector.<Rectangle>
		 */
		private function getSheetDimension():Object
		{
			var __limitW:Boolean = bmpSetting.whDDL.selectedIndex == 0;
			//frame的宽高
			var __fw:int = frameWidth;
			var __fh:int = frameHeight;
			//sheet的宽高
			var __sw:int = 0;
			var __sh:int = 0;
			//设置sheet的初始宽高
			if(__limitW)
			{
				__sw = bmpSetting.dimensionNS.value;
				__sh = __fh;
			}
			else
			{
				__sh = bmpSetting.dimensionNS.value;
				__sw = __fw;
			}
			
			var __total:int = totalFrameNS.value;
			var __rect:Rectangle = new Rectangle(0,0,__fw,__fh);
			//直接加入第一个尺寸，第一个不参与计算
			var __rects:Vector.<Rectangle> = Vector.<Rectangle>([__rect.clone()]);
			//由于第一个尺寸已经加入，循环从第二个元素开始(i=1)
			for (var i:int = 1; i < __total; i++) 
			{
				//限制宽度的计算
				if(__limitW)
				{
					//如果这一行的宽度已经不够放下当前的位图，就将其放在下一行的开头
					if(__rect.right + __fw > __sw)
					{
						__rect.x = 0;
						__rect.y += __fh;
					}
					else
					{
						__rect.x += __rect.width;
					}
					__sh = __rect.bottom;
				}
				//限制高度的计算
				else
				{
					//如果这一列的高度已经放不下当前的位图，就将其放在下一列的开头
					if(__rect.bottom + __fh > __sh)
					{
						__rect.y = 0;
						__rect.x += __fw;
					}
					else
					{
						__rect.y += __rect.height;
					}
					__sw = __rect.right;
				}
				//将计算出的位置加入Vector
				__rects[i] = __rect.clone();
			}
			return {w:__sw,h:__sh,rects:__rects};
		}
		
		//----------------------------------------
		// handler
		//----------------------------------------
		private function handler_swfLoadDone(event:Event) : void
		{
			//若当前处于等待载入状态，则开始建立sheet
			if(_state == StateType.WAIT_LOADED)
			{
				//开始capture
				capture();
			}
			else
			{
				_state = StateType.LOAD_DONE;
			}
		}
		
		private function handler_buildClick($evt:MouseEvent):void
		{
			//要生成必须重新载入swf，因为并不知晓swf当前播放到那一帧了
			_state = StateType.WAIT_LOADED;
			swf.viewer.unloadAndStop();
			swf.viewer.load(swfUrl);
		}
	]]>
	</fx:Script>
</s:HGroup>
