<?xml version="1.0" encoding="utf-8"?>
<s:HGroup xmlns:fx="http://ns.adobe.com/mxml/2009" 
		  xmlns:s="library://ns.adobe.com/flex/spark"
		  xmlns:comps="comps.*"
		  implements="interf.IStateChanged"
		  xmlns:mx="library://ns.adobe.com/flex/mx">
	<s:BorderContainer width="300" height="100%" borderColor="0x878787" backgroundAlpha="0">
		<s:layout>
			<s:VerticalLayout horizontalAlign="center" paddingBottom="5" paddingLeft="5" paddingRight="5" paddingTop="5"/>
		</s:layout>
		<s:BorderContainer width="100%" backgroundColor="0x696969">
			<s:layout>
				<s:VerticalLayout horizontalAlign="center" paddingBottom="5" paddingLeft="5" paddingRight="5" paddingTop="5"/>
			</s:layout>
			<s:Label text="帧设置(x,y,w,h)"/>
			<s:CheckBox id="useOriginalSizeCB" label="使用帧的原始大小"/>
			<s:HGroup width="100%" enabled="{!useOriginalSizeCB.selected}">
				<s:NumericStepper id="frameX" width="100%" value="@{swf.transf.x}" minimum="0" maximum="{swf.sourceWidth-1}"/>
				<s:NumericStepper id="frameY" width="100%" value="@{swf.transf.y}" minimum="0" maximum="{swf.sourceHeight-1}"/>
				<s:NumericStepper id="frameW" width="100%" value="@{swf.transf.width}" minimum="1" maximum="{swf.sourceWidth}"/>
				<s:NumericStepper id="frameH" width="100%" value="@{swf.transf.height}" minimum="1" maximum="{swf.sourceHeight}"/>
			</s:HGroup>
			<s:HGroup width="100%" verticalAlign="middle">
				<s:Label text="第一帧(0基)："/>
				<s:NumericStepper id="firstFrameNS" maximum="1000" minimum="0" stepSize="1" width="100%"/>
				<s:Label text="总帧数："/>
				<s:NumericStepper id="totalFrameNS" maximum="10000" minimum="1" value="10" stepSize="1" width="100%"/>
			</s:HGroup>
		</s:BorderContainer>
		<comps:BuildSetting id="buildSetting" width="100%" backgroundColor="0x696969"
						  enabled="{_state&amp;&amp;_state==StateType.LOAD_DONE}" 
						  build="handler_buildClick(event)"/>
	</s:BorderContainer>
	<comps:ImagePreview id="swf" width="100%" height="100%" borderColor="0x878787" backgroundAlpha="0" 
						showTransformTool="{!useOriginalSizeCB.selected}"/>
	<fx:Script>
	<![CDATA[
		import events.InfoEvent;
		
		import flash.utils.setTimeout;
		
		import mx.binding.utils.ChangeWatcher;
		import mx.events.FlexEvent;
		import mx.events.PropertyChangeEvent;
		
		import org.zengrong.display.spritesheet.SpriteSheetMetadata;
		
		import type.StateType;
		
		import utils.FileProcessor;
		import utils.Funs;
		import utils.Global;
		
		private var _swfURL:String;				//保存选择的swf文件的路径
		private var _frameNum:int;					//当前正在播放的帧的索引
		[Bindable] private var _state:String;		//当前的处理状态
		
		//----------------------------------------
		// getter/setter
		//----------------------------------------
		
		public function get frameWidth():int
		{
			return useOriginalSizeCB.selected ? swf.sourceWidth : frameW.value;
		}
		
		public function get frameHeight():int
		{
			return useOriginalSizeCB.selected ? swf.sourceHeight : frameH.value;
		}
		//----------------------------------------
		// public
		//----------------------------------------
		
		public function updateOnStateChanged($old:String, $new:String):void
		{
			trace('swfPanel updateOnStateChanged:', $new);
			if($new == StateType.SWF)
			{
				//如果是从START状态跳转过来的，就更新一次swfURL的值
				if($old == StateType.START)
					_swfURL = File(FileProcessor.instance.selectedFiles[0]).url;
				trace('swfPanel.load:', _swfURL);
				swf.addEventListener(InfoEvent.PREVIEW_LOAD_COMPLETE, handler_swfLoadDone);
				swf.source = _swfURL;
				swf.transf.init();
			}
			else
			{
				swf.removeEventListener(InfoEvent.PREVIEW_LOAD_COMPLETE, handler_swfLoadDone);
				swf.source = null;
				swf.transf.destroy();
			}
		}
		
		//----------------------------------
		//  绘制相关方法
		//----------------------------------
		
		private function capture():void
		{
			trace('swf capture');
			_state = StateType.PROCESSING;
			var __dimension:Object = getSheetDimension(
				buildSetting.whDDL.selectedIndex == 0, 
				buildSetting.dimensionNS.value,
				totalFrameNS.value);
			trace(__dimension.w, __dimension.h, __dimension.rects);
			//直接将计算好的Vector保存到metadata中
			var __meta:SpriteSheetMetadata = new SpriteSheetMetadata();
			__meta.frameSizeRect = __dimension.rects;
			var __bmd:BitmapData = new BitmapData(__dimension.w, __dimension.h, buildSetting.transparentCB.selected, buildSetting.bgColorPicker.selectedColor)
			//根据计算出的Sheet宽高重置SpriteSheet和bmd
			Funs.resetSheet(__bmd, __meta);
			//帧索引永远从0开始，无论正在播放的主时间轴有几帧（可能只有1帧，使用MC做动画），也可以实现多帧捕获
			_frameNum = 0;
			this.addEventListener(Event.EXIT_FRAME, drawFrame);
			drawFrame();
		}
		
		private function captureDone():void
		{
			_state = StateType.LOAD_DONE;
			this.removeEventListener(Event.EXIT_FRAME, drawFrame);
			Global.instance.sheet.drawSheet();
			Funs.changeState(StateType.SS);
		}
		
		/**
		 * 绘制一帧，并判断所有帧绘制是否完成
		 */
		private function drawFrame(evt:Event=null):void
		{
			if (_frameNum++ >= firstFrameNS.value)
			{
				trace('drawing frame:', _frameNum-1)
				var __bmd:BitmapData =  drawBMD();
				//向Sheet中添加这个位图
				Global.instance.sheet.addFrame(__bmd);
			}
			//所有帧捕获完毕后取消侦听
			if (_frameNum - firstFrameNS.value >= totalFrameNS.value)
			{
				captureDone();
			}
		}
		
		/**
		 * 绘制当前帧，返回位图
		 */
		private function drawBMD():BitmapData
		{
			var __bmd:BitmapData = new BitmapData(frameWidth, frameHeight, buildSetting.transparentCB.selected, buildSetting.bgColorPicker.selectedColor);
			if(useOriginalSizeCB.selected)
			{
				__bmd.draw(swf.content, null, null, null, null, buildSetting.smoothCB.selected);
			}
			else
			{
				//需要向“左上角”移动，将当前帧绘制成位图
				var __ma:Matrix = new Matrix();
				__ma.translate(-1*frameX.value, -1*frameY.value);
				__bmd.draw(swf.content, __ma, null, null, null, buildSetting.smoothCB.selected);
			}
			return __bmd;
		}
		
		/**
		 * 通过当前帧应该放置的位置
		 * @param $limitW 是否限制宽度，若为否则是限制高度
		 * @param $wh 被限制的宽度或者高度的最大值
		 * @return 返回一个Object，其中的w代表sheet宽度，h代表sheet高度，rects代表sheet中每帧的位置和大小的Vector.<Rectangle>
		 */
		private function getSheetDimension($limitW:Boolean, $wh:int, $frameNum:int):Object
		{
			//frame的宽高
			var __fw:int = frameWidth;
			var __fh:int = frameHeight;
			//sheet的宽高
			var __sw:int = 0;
			var __sh:int = 0;
			//设置sheet的初始宽高
			if($limitW)
			{
				__sw = $wh;
				__sh = __fh;
			}
			else
			{
				__sh = $wh;
				__sw = __fw;
			}
			
			var __rect:Rectangle = new Rectangle(0,0,__fw,__fh);
			//直接加入第一个尺寸，第一个不参与计算
			var __rects:Vector.<Rectangle> = Vector.<Rectangle>([__rect.clone()]);
			//由于第一个尺寸已经加入，循环从第二个元素开始(i=1)
			for (var i:int = 1; i < $frameNum; i++) 
			{
				//限制宽度的计算
				if($limitW)
				{
					
					//若限制宽度小于帧的宽度，就扩大限制宽度
					if(__sw < __fw)
					{
						__sw = __fw;
						__rect.x = 0;
						__rect.y += __fh;
					}
					//如果这一行的宽度已经不够放下当前的位图，就将其放在下一行的开头
					else if(__rect.right + __fw > __sw)
					{
						__rect.x = 0;
						__rect.y += __fh;
					}
					else
					{
						__rect.x += __rect.width;
					}
					__sh = __rect.bottom;
				}
				//限制高度的计算
				else
				{
					if(__sh < __fh)
					{
						__sh = __fh;
						__rect.y = 0;
						__rect.x += __fw;
					}
					//如果这一列的高度已经放不下当前的位图，就将其放在下一列的开头
					else if(__rect.bottom + __fh > __sh)
					{
						__rect.y = 0;
						__rect.x += __fw;
					}
					else
					{
						__rect.y += __rect.height;
					}
					__sw = __rect.right;
				}
				//将计算出的位置加入Vector
				__rects[i] = __rect.clone();
			}
			return {w:__sw,h:__sh,rects:__rects};
		}
		
		//----------------------------------------
		// handler
		//----------------------------------------
		private function handler_swfLoadDone(event:InfoEvent) : void
		{
			//若当前处于等待载入状态，则开始建立sheet
			if(_state == StateType.WAIT_LOADED)
			{
				//开始capture
				capture();
			}
			else
			{
				_state = StateType.LOAD_DONE;
			}
		}
		
		private function handler_buildClick($evt:InfoEvent):void
		{
			//要生成必须重新载入swf，因为并不知晓swf当前播放到那一帧了
			_state = StateType.WAIT_LOADED;
			swf.destroy();
			swf.source = _swfURL;
		}
	]]>
	</fx:Script>
</s:HGroup>
