<?xml version="1.0" encoding="utf-8"?>
<!-- zengrong.net -->
<!-- 创建者:zrong(zrongzrong@gmail.com) -->
<!-- 创建时间：2011-8-9 -->
<!-- 更新时间：2011-11-04 -->
<!-- 更新时间：2013-08-20 -->
<!-- 选择要拼合成SS文件的图像 -->
<s:HGroup xmlns:fx="http://ns.adobe.com/mxml/2009" 
		  xmlns:s="library://ns.adobe.com/flex/spark" 
		  horizontalAlign="center"
		  xmlns:comps="view.comps.*"
		  xmlns:widget="view.widget.*">
	<s:BorderContainer width="320" height="100%"  borderColor="0x878787" backgroundAlpha="0">
		<s:layout>
			<s:VerticalLayout horizontalAlign="center" paddingBottom="5" paddingLeft="5" paddingRight="5" paddingTop="5"/>
		</s:layout>
		<s:BorderContainer width="100%" backgroundColor="0x696969" height="80">
			<s:layout>
				<s:VerticalLayout horizontalAlign="center" paddingBottom="5" paddingLeft="5" paddingRight="5" paddingTop="5"/>
			</s:layout>
			<s:Label fontWeight="bold">
				<s:text>{FxGettext.gettext("frame(x,y,w,h)")}</s:text>
			</s:Label>
			<widget:TransformToolControlBar id="transControlBar">
				<widget:label>{FxGettext.gettext("Custom size of the frame")}</widget:label>
				<widget:useCustom>false</widget:useCustom>
				<widget:layout>
					<s:VerticalLayout horizontalAlign="center" />
				</widget:layout>
			</widget:TransformToolControlBar>
		</s:BorderContainer>
		<widget:BuildSetting id="buildSetting" width="100%" backgroundColor="0x696969"
							enabled="{fileM.fileList.length&gt;0}"/>
		<widget:FileManager id="fileM" width="100%" height="100%" 
							selectionChange="handler_selectionChange(event)" 
							selectionChanging="handler_selectionChanging(event)"/>
	</s:BorderContainer>
	<widget:ImagePreview id="pic" width="100%" height="100%" borderColor="0x878787" backgroundAlpha="0">
		<widget:transformControlBar>{transControlBar}</widget:transformControlBar>
		<widget:maxSizeLimit>viewer</widget:maxSizeLimit>
	</widget:ImagePreview>
	<fx:Script>
	<![CDATA[
		import events.SSEvent;
		
		import gnu.as3.gettext.FxGettext;
		
		import org.zengrong.display.spritesheet.SpriteSheetMetadata;
		import org.zengrong.utils.Vec2D;
		
		import vo.PicPreferenceVO;
		
		//----------------------------------------
		// getter/setter
		//----------------------------------------
		public function get preference():PicPreferenceVO
		{
			return buildSetting.preference;
		}
		/**
		 * 从当前界面控件的值中新建Rect
		 */
		public function getFrameRect():Rectangle
		{
			if(!transControlBar.useCustom)
				return new Rectangle(0,0,pic.sourceWidth, pic.sourceHeight);
			return transControlBar.transformRect;
		}
		
		/**
		 * 获取当前正在获取的帧的Rect
		 */
		public function getCaptureFrameRect($frameNum:int):Rectangle
		{
			//若使用自定义的Rect，且设置过Rect，就使用保存的Rect
			if(transControlBar.useCustom && fileM.fileList.getItemAt($frameNum).rect)
				return Rectangle(fileM.fileList.getItemAt($frameNum).rect);
			//否则从当前界面新建
			return getFrameRect();
		}
		
		//----------------------------------------
		// public
		//----------------------------------------
		//----------------------------------
		//  绘制相关方法
		//----------------------------------
		public function init():void
		{
			trace('pic init');
			//保存当前选择的文件的rect
			handler_selectionChanging(null);
			pic.viewer.source = null;
		}
		
		public function destory():void
		{
			fileM.init();
			pic.viewer.source = null;
		}
		
		/**
		 * 绘制一帧，并开始载入下一帧的图片
		 * @return 如果draw完毕，则返回true
		 */
		public function drawFrame($frameNum:int):Boolean
		{
			if ($frameNum < fileM.fileList.length)
			{
				trace('drawing frame:', $frameNum, fileM.fileList.length);
				pic.viewer.source = File(fileM.fileList.getItemAt($frameNum).file).url;
				return false;
			}
			return true;
		}
		
		/**
		 * 绘制当前帧，返回位图
		 * @param $rect 位图的大小和偏移
		 */
		public function drawBMD($rect:Rectangle):BitmapData
		{
			var __bmd:BitmapData = new BitmapData($rect.width, 
				$rect.height, 
				preference.transparent, 
				preference.bgColor);
			var __ma:Matrix = null;
			if(transControlBar.useCustom)
			{
				//需要向“左上角”移动，将当前帧绘制成位图
				__ma = new Matrix();
				__ma.translate(-1*$rect.x, -1*$rect.y);
			}
			__bmd.draw(pic.content, __ma, null, null, null, buildSetting.preference.smooth);
			return __bmd;
		}
		
		/**
		 * 获取图片名称
		 */
		public function getNames():Vector.<String>
		{
			if(fileM.fileList.length>0)
			{
				var __names:Vector.<String> = new Vector.<String>(fileM.fileList.length);
				var __dotIndex:int = 0;
				var __name:String = '';
				var __main:String = '';
				for(var i:int=0;i<fileM.fileList.length;i++)
				{
					//提取主文件名
					__name = File(fileM.fileList.getItemAt(i).file).name;
					__dotIndex = __name.lastIndexOf('.');
					if(__dotIndex == -1)
						__dotIndex = __name.length;
					__main = __name.slice(0, __dotIndex);
					__names[i] = __main;
				}
				return __names;
			}
			return null;
		}
		//----------------------------------------
		// handler
		//----------------------------------------
		/**
		 * 在切换选择的文件之前，将选择的帧rect信息保存在该item中
		 */
		protected function handler_selectionChanging($event:SSEvent):void
		{
			var __item:Object = fileM.fileDG.selectedItem;
			if(__item)
			{
				//在选择的项目被修改之前，将这个项目的Rect进行保存
				__item.rect = getFrameRect();
				trace(__item.rect);
			}
		}
		
		protected function handler_selectionChange($event:SSEvent):void
		{
			var __item:Object = fileM.fileDG.selectedItem;
			if(__item)
			{
				pic.viewer.source = __item.file.url;
				//若为这个文件记录了rect，则改变当前rect的显示
				if(__item.rect)
					pic.transf.transformRect = __item.rect;
			}
			else
			{
				pic.viewer.source = null;
			}
		}
	]]>
	</fx:Script>
</s:HGroup>
